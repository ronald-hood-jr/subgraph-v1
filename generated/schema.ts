// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class IchiVault extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("tokenA", Value.fromBytes(Bytes.empty()));
    this.set("allowTokenA", Value.fromBoolean(false));
    this.set("tokenB", Value.fromBytes(Bytes.empty()));
    this.set("allowTokenB", Value.fromBoolean(false));
    this.set("count", Value.fromBigInt(BigInt.zero()));
    this.set("fee", Value.fromBigInt(BigInt.zero()));
    this.set("createdAtTimestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save IchiVault entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IchiVault entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IchiVault", id.toString(), this);
    }
  }

  static load(id: string): IchiVault | null {
    return changetype<IchiVault | null>(store.get("IchiVault", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get tokenA(): Bytes {
    let value = this.get("tokenA");
    return value!.toBytes();
  }

  set tokenA(value: Bytes) {
    this.set("tokenA", Value.fromBytes(value));
  }

  get allowTokenA(): boolean {
    let value = this.get("allowTokenA");
    return value!.toBoolean();
  }

  set allowTokenA(value: boolean) {
    this.set("allowTokenA", Value.fromBoolean(value));
  }

  get tokenB(): Bytes {
    let value = this.get("tokenB");
    return value!.toBytes();
  }

  set tokenB(value: Bytes) {
    this.set("tokenB", Value.fromBytes(value));
  }

  get allowTokenB(): boolean {
    let value = this.get("allowTokenB");
    return value!.toBoolean();
  }

  set allowTokenB(value: boolean) {
    this.set("allowTokenB", Value.fromBoolean(value));
  }

  get count(): BigInt {
    let value = this.get("count");
    return value!.toBigInt();
  }

  set count(value: BigInt) {
    this.set("count", Value.fromBigInt(value));
  }

  get fee(): BigInt {
    let value = this.get("fee");
    return value!.toBigInt();
  }

  set fee(value: BigInt) {
    this.set("fee", Value.fromBigInt(value));
  }

  get createdAtTimestamp(): BigInt {
    let value = this.get("createdAtTimestamp");
    return value!.toBigInt();
  }

  set createdAtTimestamp(value: BigInt) {
    this.set("createdAtTimestamp", Value.fromBigInt(value));
  }
}

export class VaultAffiliate extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("vault", Value.fromBytes(Bytes.empty()));
    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("affiliate", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VaultAffiliate entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save VaultAffiliate entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("VaultAffiliate", id.toString(), this);
    }
  }

  static load(id: string): VaultAffiliate | null {
    return changetype<VaultAffiliate | null>(store.get("VaultAffiliate", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get vault(): Bytes {
    let value = this.get("vault");
    return value!.toBytes();
  }

  set vault(value: Bytes) {
    this.set("vault", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get affiliate(): Bytes {
    let value = this.get("affiliate");
    return value!.toBytes();
  }

  set affiliate(value: Bytes) {
    this.set("affiliate", Value.fromBytes(value));
  }
}

export class VaultApproval extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("vault", Value.fromBytes(Bytes.empty()));
    this.set("owner", Value.fromBytes(Bytes.empty()));
    this.set("spender", Value.fromBytes(Bytes.empty()));
    this.set("value", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VaultApproval entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save VaultApproval entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("VaultApproval", id.toString(), this);
    }
  }

  static load(id: string): VaultApproval | null {
    return changetype<VaultApproval | null>(store.get("VaultApproval", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get vault(): Bytes {
    let value = this.get("vault");
    return value!.toBytes();
  }

  set vault(value: Bytes) {
    this.set("vault", Value.fromBytes(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get spender(): Bytes {
    let value = this.get("spender");
    return value!.toBytes();
  }

  set spender(value: Bytes) {
    this.set("spender", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }
}

export class DeployICHIVault extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("vault", Value.fromString(""));
    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("pool", Value.fromBytes(Bytes.empty()));
    this.set("allowToken0", Value.fromBoolean(false));
    this.set("allowToken1", Value.fromBoolean(false));
    this.set("owner", Value.fromBytes(Bytes.empty()));
    this.set("twapPeriod", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DeployICHIVault entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DeployICHIVault entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DeployICHIVault", id.toString(), this);
    }
  }

  static load(id: string): DeployICHIVault | null {
    return changetype<DeployICHIVault | null>(store.get("DeployICHIVault", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get vault(): string {
    let value = this.get("vault");
    return value!.toString();
  }

  set vault(value: string) {
    this.set("vault", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get pool(): Bytes {
    let value = this.get("pool");
    return value!.toBytes();
  }

  set pool(value: Bytes) {
    this.set("pool", Value.fromBytes(value));
  }

  get allowToken0(): boolean {
    let value = this.get("allowToken0");
    return value!.toBoolean();
  }

  set allowToken0(value: boolean) {
    this.set("allowToken0", Value.fromBoolean(value));
  }

  get allowToken1(): boolean {
    let value = this.get("allowToken1");
    return value!.toBoolean();
  }

  set allowToken1(value: boolean) {
    this.set("allowToken1", Value.fromBoolean(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get twapPeriod(): BigInt {
    let value = this.get("twapPeriod");
    return value!.toBigInt();
  }

  set twapPeriod(value: BigInt) {
    this.set("twapPeriod", Value.fromBigInt(value));
  }
}

export class VaultDeposit extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("vault", Value.fromBytes(Bytes.empty()));
    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("to", Value.fromBytes(Bytes.empty()));
    this.set("shares", Value.fromBigInt(BigInt.zero()));
    this.set("amount0", Value.fromBigInt(BigInt.zero()));
    this.set("amount1", Value.fromBigInt(BigInt.zero()));
    this.set("createdAtTimestamp", Value.fromBigInt(BigInt.zero()));
    this.set("sqrtPrice", Value.fromBigInt(BigInt.zero()));
    this.set("totalAmount0", Value.fromBigInt(BigInt.zero()));
    this.set("totalAmount1", Value.fromBigInt(BigInt.zero()));
    this.set("totalAmount0BeforeEvent", Value.fromBigInt(BigInt.zero()));
    this.set("totalAmount1BeforeEvent", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VaultDeposit entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save VaultDeposit entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("VaultDeposit", id.toString(), this);
    }
  }

  static load(id: string): VaultDeposit | null {
    return changetype<VaultDeposit | null>(store.get("VaultDeposit", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get vault(): Bytes {
    let value = this.get("vault");
    return value!.toBytes();
  }

  set vault(value: Bytes) {
    this.set("vault", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get shares(): BigInt {
    let value = this.get("shares");
    return value!.toBigInt();
  }

  set shares(value: BigInt) {
    this.set("shares", Value.fromBigInt(value));
  }

  get amount0(): BigInt {
    let value = this.get("amount0");
    return value!.toBigInt();
  }

  set amount0(value: BigInt) {
    this.set("amount0", Value.fromBigInt(value));
  }

  get amount1(): BigInt {
    let value = this.get("amount1");
    return value!.toBigInt();
  }

  set amount1(value: BigInt) {
    this.set("amount1", Value.fromBigInt(value));
  }

  get createdAtTimestamp(): BigInt {
    let value = this.get("createdAtTimestamp");
    return value!.toBigInt();
  }

  set createdAtTimestamp(value: BigInt) {
    this.set("createdAtTimestamp", Value.fromBigInt(value));
  }

  get sqrtPrice(): BigInt {
    let value = this.get("sqrtPrice");
    return value!.toBigInt();
  }

  set sqrtPrice(value: BigInt) {
    this.set("sqrtPrice", Value.fromBigInt(value));
  }

  get totalAmount0(): BigInt {
    let value = this.get("totalAmount0");
    return value!.toBigInt();
  }

  set totalAmount0(value: BigInt) {
    this.set("totalAmount0", Value.fromBigInt(value));
  }

  get totalAmount1(): BigInt {
    let value = this.get("totalAmount1");
    return value!.toBigInt();
  }

  set totalAmount1(value: BigInt) {
    this.set("totalAmount1", Value.fromBigInt(value));
  }

  get totalAmount0BeforeEvent(): BigInt {
    let value = this.get("totalAmount0BeforeEvent");
    return value!.toBigInt();
  }

  set totalAmount0BeforeEvent(value: BigInt) {
    this.set("totalAmount0BeforeEvent", Value.fromBigInt(value));
  }

  get totalAmount1BeforeEvent(): BigInt {
    let value = this.get("totalAmount1BeforeEvent");
    return value!.toBigInt();
  }

  set totalAmount1BeforeEvent(value: BigInt) {
    this.set("totalAmount1BeforeEvent", Value.fromBigInt(value));
  }
}

export class VaultDepositMax extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("vault", Value.fromBytes(Bytes.empty()));
    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("deposit0Max", Value.fromBigInt(BigInt.zero()));
    this.set("deposit1Max", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VaultDepositMax entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save VaultDepositMax entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("VaultDepositMax", id.toString(), this);
    }
  }

  static load(id: string): VaultDepositMax | null {
    return changetype<VaultDepositMax | null>(store.get("VaultDepositMax", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get vault(): Bytes {
    let value = this.get("vault");
    return value!.toBytes();
  }

  set vault(value: Bytes) {
    this.set("vault", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get deposit0Max(): BigInt {
    let value = this.get("deposit0Max");
    return value!.toBigInt();
  }

  set deposit0Max(value: BigInt) {
    this.set("deposit0Max", Value.fromBigInt(value));
  }

  get deposit1Max(): BigInt {
    let value = this.get("deposit1Max");
    return value!.toBigInt();
  }

  set deposit1Max(value: BigInt) {
    this.set("deposit1Max", Value.fromBigInt(value));
  }
}

export class VaultHysteresis extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("vault", Value.fromBytes(Bytes.empty()));
    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("hysteresis", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VaultHysteresis entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save VaultHysteresis entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("VaultHysteresis", id.toString(), this);
    }
  }

  static load(id: string): VaultHysteresis | null {
    return changetype<VaultHysteresis | null>(store.get("VaultHysteresis", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get vault(): Bytes {
    let value = this.get("vault");
    return value!.toBytes();
  }

  set vault(value: Bytes) {
    this.set("vault", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get hysteresis(): BigInt {
    let value = this.get("hysteresis");
    return value!.toBigInt();
  }

  set hysteresis(value: BigInt) {
    this.set("hysteresis", Value.fromBigInt(value));
  }
}

export class MaxTotalSupply extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("vault", Value.fromBytes(Bytes.empty()));
    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("maxTotalSupply", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save MaxTotalSupply entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save MaxTotalSupply entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("MaxTotalSupply", id.toString(), this);
    }
  }

  static load(id: string): MaxTotalSupply | null {
    return changetype<MaxTotalSupply | null>(store.get("MaxTotalSupply", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get vault(): Bytes {
    let value = this.get("vault");
    return value!.toBytes();
  }

  set vault(value: Bytes) {
    this.set("vault", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get maxTotalSupply(): BigInt {
    let value = this.get("maxTotalSupply");
    return value!.toBigInt();
  }

  set maxTotalSupply(value: BigInt) {
    this.set("maxTotalSupply", Value.fromBigInt(value));
  }
}

export class VaultOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("vault", Value.fromBytes(Bytes.empty()));
    this.set("previousOwner", Value.fromBytes(Bytes.empty()));
    this.set("newOwner", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save VaultOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save VaultOwnershipTransferred entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("VaultOwnershipTransferred", id.toString(), this);
    }
  }

  static load(id: string): VaultOwnershipTransferred | null {
    return changetype<VaultOwnershipTransferred | null>(
      store.get("VaultOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get vault(): Bytes {
    let value = this.get("vault");
    return value!.toBytes();
  }

  set vault(value: Bytes) {
    this.set("vault", Value.fromBytes(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class VaultRebalance extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("vault", Value.fromBytes(Bytes.empty()));
    this.set("tick", Value.fromI32(0));
    this.set("totalAmount0", Value.fromBigInt(BigInt.zero()));
    this.set("totalAmount1", Value.fromBigInt(BigInt.zero()));
    this.set("feeAmount0", Value.fromBigInt(BigInt.zero()));
    this.set("feeAmount1", Value.fromBigInt(BigInt.zero()));
    this.set("totalSupply", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VaultRebalance entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save VaultRebalance entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("VaultRebalance", id.toString(), this);
    }
  }

  static load(id: string): VaultRebalance | null {
    return changetype<VaultRebalance | null>(store.get("VaultRebalance", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get vault(): Bytes {
    let value = this.get("vault");
    return value!.toBytes();
  }

  set vault(value: Bytes) {
    this.set("vault", Value.fromBytes(value));
  }

  get tick(): i32 {
    let value = this.get("tick");
    return value!.toI32();
  }

  set tick(value: i32) {
    this.set("tick", Value.fromI32(value));
  }

  get totalAmount0(): BigInt {
    let value = this.get("totalAmount0");
    return value!.toBigInt();
  }

  set totalAmount0(value: BigInt) {
    this.set("totalAmount0", Value.fromBigInt(value));
  }

  get totalAmount1(): BigInt {
    let value = this.get("totalAmount1");
    return value!.toBigInt();
  }

  set totalAmount1(value: BigInt) {
    this.set("totalAmount1", Value.fromBigInt(value));
  }

  get feeAmount0(): BigInt {
    let value = this.get("feeAmount0");
    return value!.toBigInt();
  }

  set feeAmount0(value: BigInt) {
    this.set("feeAmount0", Value.fromBigInt(value));
  }

  get feeAmount1(): BigInt {
    let value = this.get("feeAmount1");
    return value!.toBigInt();
  }

  set feeAmount1(value: BigInt) {
    this.set("feeAmount1", Value.fromBigInt(value));
  }

  get totalSupply(): BigInt {
    let value = this.get("totalSupply");
    return value!.toBigInt();
  }

  set totalSupply(value: BigInt) {
    this.set("totalSupply", Value.fromBigInt(value));
  }
}

export class VaultSetTwapPeriod extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("vault", Value.fromBytes(Bytes.empty()));
    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("newTwapPeriod", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VaultSetTwapPeriod entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save VaultSetTwapPeriod entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("VaultSetTwapPeriod", id.toString(), this);
    }
  }

  static load(id: string): VaultSetTwapPeriod | null {
    return changetype<VaultSetTwapPeriod | null>(
      store.get("VaultSetTwapPeriod", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get vault(): Bytes {
    let value = this.get("vault");
    return value!.toBytes();
  }

  set vault(value: Bytes) {
    this.set("vault", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get newTwapPeriod(): BigInt {
    let value = this.get("newTwapPeriod");
    return value!.toBigInt();
  }

  set newTwapPeriod(value: BigInt) {
    this.set("newTwapPeriod", Value.fromBigInt(value));
  }
}

export class VaultTransfer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("vault", Value.fromBytes(Bytes.empty()));
    this.set("from", Value.fromBytes(Bytes.empty()));
    this.set("to", Value.fromBytes(Bytes.empty()));
    this.set("value", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VaultTransfer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save VaultTransfer entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("VaultTransfer", id.toString(), this);
    }
  }

  static load(id: string): VaultTransfer | null {
    return changetype<VaultTransfer | null>(store.get("VaultTransfer", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get vault(): Bytes {
    let value = this.get("vault");
    return value!.toBytes();
  }

  set vault(value: Bytes) {
    this.set("vault", Value.fromBytes(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }
}

export class VaultWithdraw extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("vault", Value.fromBytes(Bytes.empty()));
    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("to", Value.fromBytes(Bytes.empty()));
    this.set("shares", Value.fromBigInt(BigInt.zero()));
    this.set("amount0", Value.fromBigInt(BigInt.zero()));
    this.set("amount1", Value.fromBigInt(BigInt.zero()));
    this.set("createdAtTimestamp", Value.fromBigInt(BigInt.zero()));
    this.set("sqrtPrice", Value.fromBigInt(BigInt.zero()));
    this.set("totalAmount0", Value.fromBigInt(BigInt.zero()));
    this.set("totalAmount1", Value.fromBigInt(BigInt.zero()));
    this.set("totalAmount0BeforeEvent", Value.fromBigInt(BigInt.zero()));
    this.set("totalAmount1BeforeEvent", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VaultWithdraw entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save VaultWithdraw entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("VaultWithdraw", id.toString(), this);
    }
  }

  static load(id: string): VaultWithdraw | null {
    return changetype<VaultWithdraw | null>(store.get("VaultWithdraw", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get vault(): Bytes {
    let value = this.get("vault");
    return value!.toBytes();
  }

  set vault(value: Bytes) {
    this.set("vault", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get shares(): BigInt {
    let value = this.get("shares");
    return value!.toBigInt();
  }

  set shares(value: BigInt) {
    this.set("shares", Value.fromBigInt(value));
  }

  get amount0(): BigInt {
    let value = this.get("amount0");
    return value!.toBigInt();
  }

  set amount0(value: BigInt) {
    this.set("amount0", Value.fromBigInt(value));
  }

  get amount1(): BigInt {
    let value = this.get("amount1");
    return value!.toBigInt();
  }

  set amount1(value: BigInt) {
    this.set("amount1", Value.fromBigInt(value));
  }

  get createdAtTimestamp(): BigInt {
    let value = this.get("createdAtTimestamp");
    return value!.toBigInt();
  }

  set createdAtTimestamp(value: BigInt) {
    this.set("createdAtTimestamp", Value.fromBigInt(value));
  }

  get sqrtPrice(): BigInt {
    let value = this.get("sqrtPrice");
    return value!.toBigInt();
  }

  set sqrtPrice(value: BigInt) {
    this.set("sqrtPrice", Value.fromBigInt(value));
  }

  get totalAmount0(): BigInt {
    let value = this.get("totalAmount0");
    return value!.toBigInt();
  }

  set totalAmount0(value: BigInt) {
    this.set("totalAmount0", Value.fromBigInt(value));
  }

  get totalAmount1(): BigInt {
    let value = this.get("totalAmount1");
    return value!.toBigInt();
  }

  set totalAmount1(value: BigInt) {
    this.set("totalAmount1", Value.fromBigInt(value));
  }

  get totalAmount0BeforeEvent(): BigInt {
    let value = this.get("totalAmount0BeforeEvent");
    return value!.toBigInt();
  }

  set totalAmount0BeforeEvent(value: BigInt) {
    this.set("totalAmount0BeforeEvent", Value.fromBigInt(value));
  }

  get totalAmount1BeforeEvent(): BigInt {
    let value = this.get("totalAmount1BeforeEvent");
    return value!.toBigInt();
  }

  set totalAmount1BeforeEvent(value: BigInt) {
    this.set("totalAmount1BeforeEvent", Value.fromBigInt(value));
  }
}

export class FarmAccount extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("pid", Value.fromBigInt(BigInt.zero()));
    this.set("user", Value.fromString(""));
    this.set("accountLPBalance", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FarmAccount entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save FarmAccount entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("FarmAccount", id.toString(), this);
    }
  }

  static load(id: string): FarmAccount | null {
    return changetype<FarmAccount | null>(store.get("FarmAccount", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pid(): BigInt {
    let value = this.get("pid");
    return value!.toBigInt();
  }

  set pid(value: BigInt) {
    this.set("pid", Value.fromBigInt(value));
  }

  get user(): string {
    let value = this.get("user");
    return value!.toString();
  }

  set user(value: string) {
    this.set("user", Value.fromString(value));
  }

  get accountLPBalance(): BigInt {
    let value = this.get("accountLPBalance");
    return value!.toBigInt();
  }

  set accountLPBalance(value: BigInt) {
    this.set("accountLPBalance", Value.fromBigInt(value));
  }
}

export class FarmUser extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FarmUser entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save FarmUser entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("FarmUser", id.toString(), this);
    }
  }

  static load(id: string): FarmUser | null {
    return changetype<FarmUser | null>(store.get("FarmUser", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get accounts(): Array<string> {
    let value = this.get("accounts");
    return value!.toStringArray();
  }

  set accounts(value: Array<string>) {
    this.set("accounts", Value.fromStringArray(value));
  }
}

export class FarmDeposit extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("user", Value.fromBytes(Bytes.empty()));
    this.set("pid", Value.fromBigInt(BigInt.zero()));
    this.set("amount", Value.fromBigInt(BigInt.zero()));
    this.set("to", Value.fromBytes(Bytes.empty()));
    this.set("timeStamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FarmDeposit entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save FarmDeposit entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("FarmDeposit", id.toString(), this);
    }
  }

  static load(id: string): FarmDeposit | null {
    return changetype<FarmDeposit | null>(store.get("FarmDeposit", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get pid(): BigInt {
    let value = this.get("pid");
    return value!.toBigInt();
  }

  set pid(value: BigInt) {
    this.set("pid", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get timeStamp(): BigInt {
    let value = this.get("timeStamp");
    return value!.toBigInt();
  }

  set timeStamp(value: BigInt) {
    this.set("timeStamp", Value.fromBigInt(value));
  }
}

export class FarmEmergencyWithdraw extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("user", Value.fromBytes(Bytes.empty()));
    this.set("pid", Value.fromBigInt(BigInt.zero()));
    this.set("amount", Value.fromBigInt(BigInt.zero()));
    this.set("to", Value.fromBytes(Bytes.empty()));
    this.set("timeStamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save FarmEmergencyWithdraw entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save FarmEmergencyWithdraw entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("FarmEmergencyWithdraw", id.toString(), this);
    }
  }

  static load(id: string): FarmEmergencyWithdraw | null {
    return changetype<FarmEmergencyWithdraw | null>(
      store.get("FarmEmergencyWithdraw", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get pid(): BigInt {
    let value = this.get("pid");
    return value!.toBigInt();
  }

  set pid(value: BigInt) {
    this.set("pid", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get timeStamp(): BigInt {
    let value = this.get("timeStamp");
    return value!.toBigInt();
  }

  set timeStamp(value: BigInt) {
    this.set("timeStamp", Value.fromBigInt(value));
  }
}

export class Farm extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("lpToken", Value.fromBytes(Bytes.empty()));
    this.set("rewardTokensPerBlock", Value.fromBigInt(BigInt.zero()));
    this.set("totalAllocPoints", Value.fromBigInt(BigInt.zero()));
    this.set("farmLPSupply", Value.fromBigInt(BigInt.zero()));
    this.set("totalLPSupply", Value.fromBigInt(BigInt.zero()));
    this.set("accIchiPerShare", Value.fromBigInt(BigInt.zero()));
    this.set("lastRewardBlock", Value.fromBigInt(BigInt.zero()));
    this.set("allocPoint", Value.fromBigInt(BigInt.zero()));
    this.set("poolIchiReward", Value.fromBigInt(BigInt.zero()));
    this.set("ichiPerBlock", Value.fromBigInt(BigInt.zero()));
    this.set("lpTokenSymbol", Value.fromString(""));
    this.set("lpTokenDecimals", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Farm entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Farm entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Farm", id.toString(), this);
    }
  }

  static load(id: string): Farm | null {
    return changetype<Farm | null>(store.get("Farm", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get lpToken(): Bytes {
    let value = this.get("lpToken");
    return value!.toBytes();
  }

  set lpToken(value: Bytes) {
    this.set("lpToken", Value.fromBytes(value));
  }

  get rewardTokensPerBlock(): BigInt {
    let value = this.get("rewardTokensPerBlock");
    return value!.toBigInt();
  }

  set rewardTokensPerBlock(value: BigInt) {
    this.set("rewardTokensPerBlock", Value.fromBigInt(value));
  }

  get totalAllocPoints(): BigInt {
    let value = this.get("totalAllocPoints");
    return value!.toBigInt();
  }

  set totalAllocPoints(value: BigInt) {
    this.set("totalAllocPoints", Value.fromBigInt(value));
  }

  get farmLPSupply(): BigInt {
    let value = this.get("farmLPSupply");
    return value!.toBigInt();
  }

  set farmLPSupply(value: BigInt) {
    this.set("farmLPSupply", Value.fromBigInt(value));
  }

  get totalLPSupply(): BigInt {
    let value = this.get("totalLPSupply");
    return value!.toBigInt();
  }

  set totalLPSupply(value: BigInt) {
    this.set("totalLPSupply", Value.fromBigInt(value));
  }

  get accIchiPerShare(): BigInt {
    let value = this.get("accIchiPerShare");
    return value!.toBigInt();
  }

  set accIchiPerShare(value: BigInt) {
    this.set("accIchiPerShare", Value.fromBigInt(value));
  }

  get lastRewardBlock(): BigInt {
    let value = this.get("lastRewardBlock");
    return value!.toBigInt();
  }

  set lastRewardBlock(value: BigInt) {
    this.set("lastRewardBlock", Value.fromBigInt(value));
  }

  get allocPoint(): BigInt {
    let value = this.get("allocPoint");
    return value!.toBigInt();
  }

  set allocPoint(value: BigInt) {
    this.set("allocPoint", Value.fromBigInt(value));
  }

  get poolIchiReward(): BigInt {
    let value = this.get("poolIchiReward");
    return value!.toBigInt();
  }

  set poolIchiReward(value: BigInt) {
    this.set("poolIchiReward", Value.fromBigInt(value));
  }

  get ichiPerBlock(): BigInt {
    let value = this.get("ichiPerBlock");
    return value!.toBigInt();
  }

  set ichiPerBlock(value: BigInt) {
    this.set("ichiPerBlock", Value.fromBigInt(value));
  }

  get lpTokenSymbol(): string {
    let value = this.get("lpTokenSymbol");
    return value!.toString();
  }

  set lpTokenSymbol(value: string) {
    this.set("lpTokenSymbol", Value.fromString(value));
  }

  get lpTokenDecimals(): BigInt {
    let value = this.get("lpTokenDecimals");
    return value!.toBigInt();
  }

  set lpTokenDecimals(value: BigInt) {
    this.set("lpTokenDecimals", Value.fromBigInt(value));
  }
}

export class FarmHarvest extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("user", Value.fromBytes(Bytes.empty()));
    this.set("pid", Value.fromBigInt(BigInt.zero()));
    this.set("amount", Value.fromBigInt(BigInt.zero()));
    this.set("timeStamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FarmHarvest entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save FarmHarvest entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("FarmHarvest", id.toString(), this);
    }
  }

  static load(id: string): FarmHarvest | null {
    return changetype<FarmHarvest | null>(store.get("FarmHarvest", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get pid(): BigInt {
    let value = this.get("pid");
    return value!.toBigInt();
  }

  set pid(value: BigInt) {
    this.set("pid", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get timeStamp(): BigInt {
    let value = this.get("timeStamp");
    return value!.toBigInt();
  }

  set timeStamp(value: BigInt) {
    this.set("timeStamp", Value.fromBigInt(value));
  }
}

export class FarmWithdraw extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("user", Value.fromBytes(Bytes.empty()));
    this.set("pid", Value.fromBigInt(BigInt.zero()));
    this.set("amount", Value.fromBigInt(BigInt.zero()));
    this.set("to", Value.fromBytes(Bytes.empty()));
    this.set("timeStamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FarmWithdraw entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save FarmWithdraw entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("FarmWithdraw", id.toString(), this);
    }
  }

  static load(id: string): FarmWithdraw | null {
    return changetype<FarmWithdraw | null>(store.get("FarmWithdraw", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get pid(): BigInt {
    let value = this.get("pid");
    return value!.toBigInt();
  }

  set pid(value: BigInt) {
    this.set("pid", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get timeStamp(): BigInt {
    let value = this.get("timeStamp");
    return value!.toBigInt();
  }

  set timeStamp(value: BigInt) {
    this.set("timeStamp", Value.fromBigInt(value));
  }
}

export class FarmLogPoolAddition extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("pid", Value.fromBigInt(BigInt.zero()));
    this.set("allocPoint", Value.fromBigInt(BigInt.zero()));
    this.set("lpToken", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FarmLogPoolAddition entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save FarmLogPoolAddition entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("FarmLogPoolAddition", id.toString(), this);
    }
  }

  static load(id: string): FarmLogPoolAddition | null {
    return changetype<FarmLogPoolAddition | null>(
      store.get("FarmLogPoolAddition", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pid(): BigInt {
    let value = this.get("pid");
    return value!.toBigInt();
  }

  set pid(value: BigInt) {
    this.set("pid", Value.fromBigInt(value));
  }

  get allocPoint(): BigInt {
    let value = this.get("allocPoint");
    return value!.toBigInt();
  }

  set allocPoint(value: BigInt) {
    this.set("allocPoint", Value.fromBigInt(value));
  }

  get lpToken(): Bytes {
    let value = this.get("lpToken");
    return value!.toBytes();
  }

  set lpToken(value: Bytes) {
    this.set("lpToken", Value.fromBytes(value));
  }
}

export class FarmLogSetPool extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("pid", Value.fromBigInt(BigInt.zero()));
    this.set("allocPoint", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FarmLogSetPool entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save FarmLogSetPool entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("FarmLogSetPool", id.toString(), this);
    }
  }

  static load(id: string): FarmLogSetPool | null {
    return changetype<FarmLogSetPool | null>(store.get("FarmLogSetPool", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pid(): BigInt {
    let value = this.get("pid");
    return value!.toBigInt();
  }

  set pid(value: BigInt) {
    this.set("pid", Value.fromBigInt(value));
  }

  get allocPoint(): BigInt {
    let value = this.get("allocPoint");
    return value!.toBigInt();
  }

  set allocPoint(value: BigInt) {
    this.set("allocPoint", Value.fromBigInt(value));
  }
}

export class FarmLogUpdatePool extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("pid", Value.fromBigInt(BigInt.zero()));
    this.set("lastRewardBlock", Value.fromBigInt(BigInt.zero()));
    this.set("lpSupply", Value.fromBigInt(BigInt.zero()));
    this.set("accIchiPerShare", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FarmLogUpdatePool entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save FarmLogUpdatePool entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("FarmLogUpdatePool", id.toString(), this);
    }
  }

  static load(id: string): FarmLogUpdatePool | null {
    return changetype<FarmLogUpdatePool | null>(
      store.get("FarmLogUpdatePool", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pid(): BigInt {
    let value = this.get("pid");
    return value!.toBigInt();
  }

  set pid(value: BigInt) {
    this.set("pid", Value.fromBigInt(value));
  }

  get lastRewardBlock(): BigInt {
    let value = this.get("lastRewardBlock");
    return value!.toBigInt();
  }

  set lastRewardBlock(value: BigInt) {
    this.set("lastRewardBlock", Value.fromBigInt(value));
  }

  get lpSupply(): BigInt {
    let value = this.get("lpSupply");
    return value!.toBigInt();
  }

  set lpSupply(value: BigInt) {
    this.set("lpSupply", Value.fromBigInt(value));
  }

  get accIchiPerShare(): BigInt {
    let value = this.get("accIchiPerShare");
    return value!.toBigInt();
  }

  set accIchiPerShare(value: BigInt) {
    this.set("accIchiPerShare", Value.fromBigInt(value));
  }
}

export class FarmOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("previousOwner", Value.fromBytes(Bytes.empty()));
    this.set("newOwner", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save FarmOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save FarmOwnershipTransferred entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("FarmOwnershipTransferred", id.toString(), this);
    }
  }

  static load(id: string): FarmOwnershipTransferred | null {
    return changetype<FarmOwnershipTransferred | null>(
      store.get("FarmOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class FarmSetIchiPerBlock extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("ichiPerBlock", Value.fromBigInt(BigInt.zero()));
    this.set("withUpdate", Value.fromBoolean(false));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FarmSetIchiPerBlock entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save FarmSetIchiPerBlock entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("FarmSetIchiPerBlock", id.toString(), this);
    }
  }

  static load(id: string): FarmSetIchiPerBlock | null {
    return changetype<FarmSetIchiPerBlock | null>(
      store.get("FarmSetIchiPerBlock", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get ichiPerBlock(): BigInt {
    let value = this.get("ichiPerBlock");
    return value!.toBigInt();
  }

  set ichiPerBlock(value: BigInt) {
    this.set("ichiPerBlock", Value.fromBigInt(value));
  }

  get withUpdate(): boolean {
    let value = this.get("withUpdate");
    return value!.toBoolean();
  }

  set withUpdate(value: boolean) {
    this.set("withUpdate", Value.fromBoolean(value));
  }
}

export class OneTokenFactoryAddOracle extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("foreignToken", Value.fromBytes(Bytes.empty()));
    this.set("oracle", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OneTokenFactoryAddOracle entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenFactoryAddOracle entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenFactoryAddOracle", id.toString(), this);
    }
  }

  static load(id: string): OneTokenFactoryAddOracle | null {
    return changetype<OneTokenFactoryAddOracle | null>(
      store.get("OneTokenFactoryAddOracle", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get foreignToken(): Bytes {
    let value = this.get("foreignToken");
    return value!.toBytes();
  }

  set foreignToken(value: Bytes) {
    this.set("foreignToken", Value.fromBytes(value));
  }

  get oracle(): Bytes {
    let value = this.get("oracle");
    return value!.toBytes();
  }

  set oracle(value: Bytes) {
    this.set("oracle", Value.fromBytes(value));
  }
}

export class OneTokenFactoryForeignTokenAdmitted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("foreignToken", Value.fromBytes(Bytes.empty()));
    this.set("isCollateral", Value.fromBoolean(false));
    this.set("oracle", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OneTokenFactoryForeignTokenAdmitted entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenFactoryForeignTokenAdmitted entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenFactoryForeignTokenAdmitted", id.toString(), this);
    }
  }

  static load(id: string): OneTokenFactoryForeignTokenAdmitted | null {
    return changetype<OneTokenFactoryForeignTokenAdmitted | null>(
      store.get("OneTokenFactoryForeignTokenAdmitted", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get foreignToken(): Bytes {
    let value = this.get("foreignToken");
    return value!.toBytes();
  }

  set foreignToken(value: Bytes) {
    this.set("foreignToken", Value.fromBytes(value));
  }

  get isCollateral(): boolean {
    let value = this.get("isCollateral");
    return value!.toBoolean();
  }

  set isCollateral(value: boolean) {
    this.set("isCollateral", Value.fromBoolean(value));
  }

  get oracle(): Bytes {
    let value = this.get("oracle");
    return value!.toBytes();
  }

  set oracle(value: Bytes) {
    this.set("oracle", Value.fromBytes(value));
  }
}

export class OneTokenFactoryForeignTokenRemoved extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("foreignToken", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OneTokenFactoryForeignTokenRemoved entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenFactoryForeignTokenRemoved entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenFactoryForeignTokenRemoved", id.toString(), this);
    }
  }

  static load(id: string): OneTokenFactoryForeignTokenRemoved | null {
    return changetype<OneTokenFactoryForeignTokenRemoved | null>(
      store.get("OneTokenFactoryForeignTokenRemoved", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get foreignToken(): Bytes {
    let value = this.get("foreignToken");
    return value!.toBytes();
  }

  set foreignToken(value: Bytes) {
    this.set("foreignToken", Value.fromBytes(value));
  }
}

export class OneTokenFactoryForeignTokenUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("foreignToken", Value.fromBytes(Bytes.empty()));
    this.set("isCollateral", Value.fromBoolean(false));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OneTokenFactoryForeignTokenUpdated entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenFactoryForeignTokenUpdated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenFactoryForeignTokenUpdated", id.toString(), this);
    }
  }

  static load(id: string): OneTokenFactoryForeignTokenUpdated | null {
    return changetype<OneTokenFactoryForeignTokenUpdated | null>(
      store.get("OneTokenFactoryForeignTokenUpdated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get foreignToken(): Bytes {
    let value = this.get("foreignToken");
    return value!.toBytes();
  }

  set foreignToken(value: Bytes) {
    this.set("foreignToken", Value.fromBytes(value));
  }

  get isCollateral(): boolean {
    let value = this.get("isCollateral");
    return value!.toBoolean();
  }

  set isCollateral(value: boolean) {
    this.set("isCollateral", Value.fromBoolean(value));
  }
}

export class OneTokenFactoryModuleAdmitted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("module", Value.fromBytes(Bytes.empty()));
    this.set("moduleType", Value.fromI32(0));
    this.set("name", Value.fromString(""));
    this.set("url", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OneTokenFactoryModuleAdmitted entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenFactoryModuleAdmitted entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenFactoryModuleAdmitted", id.toString(), this);
    }
  }

  static load(id: string): OneTokenFactoryModuleAdmitted | null {
    return changetype<OneTokenFactoryModuleAdmitted | null>(
      store.get("OneTokenFactoryModuleAdmitted", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get module(): Bytes {
    let value = this.get("module");
    return value!.toBytes();
  }

  set module(value: Bytes) {
    this.set("module", Value.fromBytes(value));
  }

  get moduleType(): i32 {
    let value = this.get("moduleType");
    return value!.toI32();
  }

  set moduleType(value: i32) {
    this.set("moduleType", Value.fromI32(value));
  }

  get name(): string {
    let value = this.get("name");
    return value!.toString();
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get url(): string {
    let value = this.get("url");
    return value!.toString();
  }

  set url(value: string) {
    this.set("url", Value.fromString(value));
  }
}

export class OneTokenFactoryModuleRemoved extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("module", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OneTokenFactoryModuleRemoved entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenFactoryModuleRemoved entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenFactoryModuleRemoved", id.toString(), this);
    }
  }

  static load(id: string): OneTokenFactoryModuleRemoved | null {
    return changetype<OneTokenFactoryModuleRemoved | null>(
      store.get("OneTokenFactoryModuleRemoved", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get module(): Bytes {
    let value = this.get("module");
    return value!.toBytes();
  }

  set module(value: Bytes) {
    this.set("module", Value.fromBytes(value));
  }
}

export class OneTokenFactoryModuleUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("module", Value.fromBytes(Bytes.empty()));
    this.set("name", Value.fromString(""));
    this.set("url", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OneTokenFactoryModuleUpdated entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenFactoryModuleUpdated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenFactoryModuleUpdated", id.toString(), this);
    }
  }

  static load(id: string): OneTokenFactoryModuleUpdated | null {
    return changetype<OneTokenFactoryModuleUpdated | null>(
      store.get("OneTokenFactoryModuleUpdated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get module(): Bytes {
    let value = this.get("module");
    return value!.toBytes();
  }

  set module(value: Bytes) {
    this.set("module", Value.fromBytes(value));
  }

  get name(): string {
    let value = this.get("name");
    return value!.toString();
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get url(): string {
    let value = this.get("url");
    return value!.toString();
  }

  set url(value: string) {
    this.set("url", Value.fromString(value));
  }
}

export class OneTokenFactoryOneTokenAdmin extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("newOneTokenProxy", Value.fromBytes(Bytes.empty()));
    this.set("proxyAdmin", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OneTokenFactoryOneTokenAdmin entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenFactoryOneTokenAdmin entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenFactoryOneTokenAdmin", id.toString(), this);
    }
  }

  static load(id: string): OneTokenFactoryOneTokenAdmin | null {
    return changetype<OneTokenFactoryOneTokenAdmin | null>(
      store.get("OneTokenFactoryOneTokenAdmin", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get newOneTokenProxy(): Bytes {
    let value = this.get("newOneTokenProxy");
    return value!.toBytes();
  }

  set newOneTokenProxy(value: Bytes) {
    this.set("newOneTokenProxy", Value.fromBytes(value));
  }

  get proxyAdmin(): Bytes {
    let value = this.get("proxyAdmin");
    return value!.toBytes();
  }

  set proxyAdmin(value: Bytes) {
    this.set("proxyAdmin", Value.fromBytes(value));
  }
}

export class OneTokenFactoryOneTokenDeployed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("newOneTokenProxy", Value.fromBytes(Bytes.empty()));
    this.set("name", Value.fromString(""));
    this.set("symbol", Value.fromString(""));
    this.set("governance", Value.fromBytes(Bytes.empty()));
    this.set("version", Value.fromBytes(Bytes.empty()));
    this.set("controller", Value.fromBytes(Bytes.empty()));
    this.set("mintMaster", Value.fromBytes(Bytes.empty()));
    this.set("oneTokenOracle", Value.fromBytes(Bytes.empty()));
    this.set("memberToken", Value.fromBytes(Bytes.empty()));
    this.set("collateral", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OneTokenFactoryOneTokenDeployed entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenFactoryOneTokenDeployed entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenFactoryOneTokenDeployed", id.toString(), this);
    }
  }

  static load(id: string): OneTokenFactoryOneTokenDeployed | null {
    return changetype<OneTokenFactoryOneTokenDeployed | null>(
      store.get("OneTokenFactoryOneTokenDeployed", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get newOneTokenProxy(): Bytes {
    let value = this.get("newOneTokenProxy");
    return value!.toBytes();
  }

  set newOneTokenProxy(value: Bytes) {
    this.set("newOneTokenProxy", Value.fromBytes(value));
  }

  get name(): string {
    let value = this.get("name");
    return value!.toString();
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get symbol(): string {
    let value = this.get("symbol");
    return value!.toString();
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value));
  }

  get governance(): Bytes {
    let value = this.get("governance");
    return value!.toBytes();
  }

  set governance(value: Bytes) {
    this.set("governance", Value.fromBytes(value));
  }

  get version(): Bytes {
    let value = this.get("version");
    return value!.toBytes();
  }

  set version(value: Bytes) {
    this.set("version", Value.fromBytes(value));
  }

  get controller(): Bytes {
    let value = this.get("controller");
    return value!.toBytes();
  }

  set controller(value: Bytes) {
    this.set("controller", Value.fromBytes(value));
  }

  get mintMaster(): Bytes {
    let value = this.get("mintMaster");
    return value!.toBytes();
  }

  set mintMaster(value: Bytes) {
    this.set("mintMaster", Value.fromBytes(value));
  }

  get oneTokenOracle(): Bytes {
    let value = this.get("oneTokenOracle");
    return value!.toBytes();
  }

  set oneTokenOracle(value: Bytes) {
    this.set("oneTokenOracle", Value.fromBytes(value));
  }

  get memberToken(): Bytes {
    let value = this.get("memberToken");
    return value!.toBytes();
  }

  set memberToken(value: Bytes) {
    this.set("memberToken", Value.fromBytes(value));
  }

  get collateral(): Bytes {
    let value = this.get("collateral");
    return value!.toBytes();
  }

  set collateral(value: Bytes) {
    this.set("collateral", Value.fromBytes(value));
  }
}

export class OneTokenFactoryOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("previousOwner", Value.fromBytes(Bytes.empty()));
    this.set("newOwner", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OneTokenFactoryOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenFactoryOwnershipTransferred entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenFactoryOwnershipTransferred", id.toString(), this);
    }
  }

  static load(id: string): OneTokenFactoryOwnershipTransferred | null {
    return changetype<OneTokenFactoryOwnershipTransferred | null>(
      store.get("OneTokenFactoryOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class OneTokenFactoryRemoveOracle extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("foreignToken", Value.fromBytes(Bytes.empty()));
    this.set("oracle", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OneTokenFactoryRemoveOracle entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenFactoryRemoveOracle entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenFactoryRemoveOracle", id.toString(), this);
    }
  }

  static load(id: string): OneTokenFactoryRemoveOracle | null {
    return changetype<OneTokenFactoryRemoveOracle | null>(
      store.get("OneTokenFactoryRemoveOracle", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get foreignToken(): Bytes {
    let value = this.get("foreignToken");
    return value!.toBytes();
  }

  set foreignToken(value: Bytes) {
    this.set("foreignToken", Value.fromBytes(value));
  }

  get oracle(): Bytes {
    let value = this.get("oracle");
    return value!.toBytes();
  }

  set oracle(value: Bytes) {
    this.set("oracle", Value.fromBytes(value));
  }
}

export class OneTokenAdminChanged extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("previousAdmin", Value.fromBytes(Bytes.empty()));
    this.set("newAdmin", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OneTokenAdminChanged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenAdminChanged entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenAdminChanged", id.toString(), this);
    }
  }

  static load(id: string): OneTokenAdminChanged | null {
    return changetype<OneTokenAdminChanged | null>(
      store.get("OneTokenAdminChanged", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousAdmin(): Bytes {
    let value = this.get("previousAdmin");
    return value!.toBytes();
  }

  set previousAdmin(value: Bytes) {
    this.set("previousAdmin", Value.fromBytes(value));
  }

  get newAdmin(): Bytes {
    let value = this.get("newAdmin");
    return value!.toBytes();
  }

  set newAdmin(value: Bytes) {
    this.set("newAdmin", Value.fromBytes(value));
  }
}

export class OneTokenUpgraded extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("implementation", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OneTokenUpgraded entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenUpgraded entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenUpgraded", id.toString(), this);
    }
  }

  static load(id: string): OneTokenUpgraded | null {
    return changetype<OneTokenUpgraded | null>(
      store.get("OneTokenUpgraded", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get implementation(): Bytes {
    let value = this.get("implementation");
    return value!.toBytes();
  }

  set implementation(value: Bytes) {
    this.set("implementation", Value.fromBytes(value));
  }
}

export class OneTokenApproval extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("owner", Value.fromBytes(Bytes.empty()));
    this.set("spender", Value.fromBytes(Bytes.empty()));
    this.set("value", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OneTokenApproval entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenApproval entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenApproval", id.toString(), this);
    }
  }

  static load(id: string): OneTokenApproval | null {
    return changetype<OneTokenApproval | null>(
      store.get("OneTokenApproval", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get spender(): Bytes {
    let value = this.get("spender");
    return value!.toBytes();
  }

  set spender(value: Bytes) {
    this.set("spender", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }
}

export class OneTokenAssetAdded extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("token", Value.fromBytes(Bytes.empty()));
    this.set("oracle", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OneTokenAssetAdded entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenAssetAdded entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenAssetAdded", id.toString(), this);
    }
  }

  static load(id: string): OneTokenAssetAdded | null {
    return changetype<OneTokenAssetAdded | null>(
      store.get("OneTokenAssetAdded", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value!.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get oracle(): Bytes {
    let value = this.get("oracle");
    return value!.toBytes();
  }

  set oracle(value: Bytes) {
    this.set("oracle", Value.fromBytes(value));
  }
}

export class OneTokenAssetRemoved extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("token", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OneTokenAssetRemoved entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenAssetRemoved entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenAssetRemoved", id.toString(), this);
    }
  }

  static load(id: string): OneTokenAssetRemoved | null {
    return changetype<OneTokenAssetRemoved | null>(
      store.get("OneTokenAssetRemoved", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value!.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }
}

export class OneTokenControllerChanged extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("controller", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OneTokenControllerChanged entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenControllerChanged entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenControllerChanged", id.toString(), this);
    }
  }

  static load(id: string): OneTokenControllerChanged | null {
    return changetype<OneTokenControllerChanged | null>(
      store.get("OneTokenControllerChanged", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get controller(): Bytes {
    let value = this.get("controller");
    return value!.toBytes();
  }

  set controller(value: Bytes) {
    this.set("controller", Value.fromBytes(value));
  }
}

export class OneTokenFromStrategy extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("strategy", Value.fromBytes(Bytes.empty()));
    this.set("token", Value.fromBytes(Bytes.empty()));
    this.set("amount", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OneTokenFromStrategy entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenFromStrategy entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenFromStrategy", id.toString(), this);
    }
  }

  static load(id: string): OneTokenFromStrategy | null {
    return changetype<OneTokenFromStrategy | null>(
      store.get("OneTokenFromStrategy", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get strategy(): Bytes {
    let value = this.get("strategy");
    return value!.toBytes();
  }

  set strategy(value: Bytes) {
    this.set("strategy", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value!.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class OneTokenInitialized extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("name", Value.fromString(""));
    this.set("symbol", Value.fromString(""));
    this.set("controller", Value.fromBytes(Bytes.empty()));
    this.set("mintMaster", Value.fromBytes(Bytes.empty()));
    this.set("memberToken", Value.fromBytes(Bytes.empty()));
    this.set("collateral", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OneTokenInitialized entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenInitialized entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenInitialized", id.toString(), this);
    }
  }

  static load(id: string): OneTokenInitialized | null {
    return changetype<OneTokenInitialized | null>(
      store.get("OneTokenInitialized", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get name(): string {
    let value = this.get("name");
    return value!.toString();
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get symbol(): string {
    let value = this.get("symbol");
    return value!.toString();
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value));
  }

  get controller(): Bytes {
    let value = this.get("controller");
    return value!.toBytes();
  }

  set controller(value: Bytes) {
    this.set("controller", Value.fromBytes(value));
  }

  get mintMaster(): Bytes {
    let value = this.get("mintMaster");
    return value!.toBytes();
  }

  set mintMaster(value: Bytes) {
    this.set("mintMaster", Value.fromBytes(value));
  }

  get memberToken(): Bytes {
    let value = this.get("memberToken");
    return value!.toBytes();
  }

  set memberToken(value: Bytes) {
    this.set("memberToken", Value.fromBytes(value));
  }

  get collateral(): Bytes {
    let value = this.get("collateral");
    return value!.toBytes();
  }

  set collateral(value: Bytes) {
    this.set("collateral", Value.fromBytes(value));
  }
}

export class OneTokenMintMasterChanged extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("mintMaster", Value.fromBytes(Bytes.empty()));
    this.set("oneTokenOracle", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OneTokenMintMasterChanged entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenMintMasterChanged entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenMintMasterChanged", id.toString(), this);
    }
  }

  static load(id: string): OneTokenMintMasterChanged | null {
    return changetype<OneTokenMintMasterChanged | null>(
      store.get("OneTokenMintMasterChanged", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get mintMaster(): Bytes {
    let value = this.get("mintMaster");
    return value!.toBytes();
  }

  set mintMaster(value: Bytes) {
    this.set("mintMaster", Value.fromBytes(value));
  }

  get oneTokenOracle(): Bytes {
    let value = this.get("oneTokenOracle");
    return value!.toBytes();
  }

  set oneTokenOracle(value: Bytes) {
    this.set("oneTokenOracle", Value.fromBytes(value));
  }
}

export class OneTokenMinted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("collateral", Value.fromBytes(Bytes.empty()));
    this.set("oneTokens", Value.fromBigInt(BigInt.zero()));
    this.set("memberTokens", Value.fromBigInt(BigInt.zero()));
    this.set("collateralTokens", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OneTokenMinted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenMinted entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenMinted", id.toString(), this);
    }
  }

  static load(id: string): OneTokenMinted | null {
    return changetype<OneTokenMinted | null>(store.get("OneTokenMinted", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get collateral(): Bytes {
    let value = this.get("collateral");
    return value!.toBytes();
  }

  set collateral(value: Bytes) {
    this.set("collateral", Value.fromBytes(value));
  }

  get oneTokens(): BigInt {
    let value = this.get("oneTokens");
    return value!.toBigInt();
  }

  set oneTokens(value: BigInt) {
    this.set("oneTokens", Value.fromBigInt(value));
  }

  get memberTokens(): BigInt {
    let value = this.get("memberTokens");
    return value!.toBigInt();
  }

  set memberTokens(value: BigInt) {
    this.set("memberTokens", Value.fromBigInt(value));
  }

  get collateralTokens(): BigInt {
    let value = this.get("collateralTokens");
    return value!.toBigInt();
  }

  set collateralTokens(value: BigInt) {
    this.set("collateralTokens", Value.fromBigInt(value));
  }
}

export class OneTokenNewFactory extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("factory", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OneTokenNewFactory entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenNewFactory entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenNewFactory", id.toString(), this);
    }
  }

  static load(id: string): OneTokenNewFactory | null {
    return changetype<OneTokenNewFactory | null>(
      store.get("OneTokenNewFactory", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get factory(): Bytes {
    let value = this.get("factory");
    return value!.toBytes();
  }

  set factory(value: Bytes) {
    this.set("factory", Value.fromBytes(value));
  }
}

export class OneTokenNewMintingFee extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("fee", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OneTokenNewMintingFee entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenNewMintingFee entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenNewMintingFee", id.toString(), this);
    }
  }

  static load(id: string): OneTokenNewMintingFee | null {
    return changetype<OneTokenNewMintingFee | null>(
      store.get("OneTokenNewMintingFee", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get fee(): BigInt {
    let value = this.get("fee");
    return value!.toBigInt();
  }

  set fee(value: BigInt) {
    this.set("fee", Value.fromBigInt(value));
  }
}

export class OneTokenNewRedemptionFee extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("fee", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OneTokenNewRedemptionFee entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenNewRedemptionFee entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenNewRedemptionFee", id.toString(), this);
    }
  }

  static load(id: string): OneTokenNewRedemptionFee | null {
    return changetype<OneTokenNewRedemptionFee | null>(
      store.get("OneTokenNewRedemptionFee", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get fee(): BigInt {
    let value = this.get("fee");
    return value!.toBigInt();
  }

  set fee(value: BigInt) {
    this.set("fee", Value.fromBigInt(value));
  }
}

export class OneTokenOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("previousOwner", Value.fromBytes(Bytes.empty()));
    this.set("newOwner", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OneTokenOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenOwnershipTransferred entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenOwnershipTransferred", id.toString(), this);
    }
  }

  static load(id: string): OneTokenOwnershipTransferred | null {
    return changetype<OneTokenOwnershipTransferred | null>(
      store.get("OneTokenOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class OneTokenRedeemed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("collateral", Value.fromBytes(Bytes.empty()));
    this.set("amount", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OneTokenRedeemed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenRedeemed entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenRedeemed", id.toString(), this);
    }
  }

  static load(id: string): OneTokenRedeemed | null {
    return changetype<OneTokenRedeemed | null>(
      store.get("OneTokenRedeemed", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get collateral(): Bytes {
    let value = this.get("collateral");
    return value!.toBytes();
  }

  set collateral(value: Bytes) {
    this.set("collateral", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class OneTokenStrategyAllowanceDecreased extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("token", Value.fromBytes(Bytes.empty()));
    this.set("strategy", Value.fromBytes(Bytes.empty()));
    this.set("amount", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OneTokenStrategyAllowanceDecreased entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenStrategyAllowanceDecreased entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenStrategyAllowanceDecreased", id.toString(), this);
    }
  }

  static load(id: string): OneTokenStrategyAllowanceDecreased | null {
    return changetype<OneTokenStrategyAllowanceDecreased | null>(
      store.get("OneTokenStrategyAllowanceDecreased", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value!.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get strategy(): Bytes {
    let value = this.get("strategy");
    return value!.toBytes();
  }

  set strategy(value: Bytes) {
    this.set("strategy", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class OneTokenStrategyAllowanceIncreased extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("token", Value.fromBytes(Bytes.empty()));
    this.set("strategy", Value.fromBytes(Bytes.empty()));
    this.set("amount", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OneTokenStrategyAllowanceIncreased entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenStrategyAllowanceIncreased entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenStrategyAllowanceIncreased", id.toString(), this);
    }
  }

  static load(id: string): OneTokenStrategyAllowanceIncreased | null {
    return changetype<OneTokenStrategyAllowanceIncreased | null>(
      store.get("OneTokenStrategyAllowanceIncreased", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value!.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get strategy(): Bytes {
    let value = this.get("strategy");
    return value!.toBytes();
  }

  set strategy(value: Bytes) {
    this.set("strategy", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class OneTokenStrategyClosed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("token", Value.fromBytes(Bytes.empty()));
    this.set("strategy", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OneTokenStrategyClosed entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenStrategyClosed entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenStrategyClosed", id.toString(), this);
    }
  }

  static load(id: string): OneTokenStrategyClosed | null {
    return changetype<OneTokenStrategyClosed | null>(
      store.get("OneTokenStrategyClosed", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value!.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get strategy(): Bytes {
    let value = this.get("strategy");
    return value!.toBytes();
  }

  set strategy(value: Bytes) {
    this.set("strategy", Value.fromBytes(value));
  }
}

export class OneTokenStrategyExecuted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("token", Value.fromBytes(Bytes.empty()));
    this.set("strategy", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OneTokenStrategyExecuted entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenStrategyExecuted entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenStrategyExecuted", id.toString(), this);
    }
  }

  static load(id: string): OneTokenStrategyExecuted | null {
    return changetype<OneTokenStrategyExecuted | null>(
      store.get("OneTokenStrategyExecuted", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value!.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get strategy(): Bytes {
    let value = this.get("strategy");
    return value!.toBytes();
  }

  set strategy(value: Bytes) {
    this.set("strategy", Value.fromBytes(value));
  }
}

export class OneTokenStrategyRemoved extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("token", Value.fromBytes(Bytes.empty()));
    this.set("strategy", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OneTokenStrategyRemoved entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenStrategyRemoved entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenStrategyRemoved", id.toString(), this);
    }
  }

  static load(id: string): OneTokenStrategyRemoved | null {
    return changetype<OneTokenStrategyRemoved | null>(
      store.get("OneTokenStrategyRemoved", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value!.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get strategy(): Bytes {
    let value = this.get("strategy");
    return value!.toBytes();
  }

  set strategy(value: Bytes) {
    this.set("strategy", Value.fromBytes(value));
  }
}

export class OneTokenStrategySet extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("token", Value.fromBytes(Bytes.empty()));
    this.set("strategy", Value.fromBytes(Bytes.empty()));
    this.set("allowance", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OneTokenStrategySet entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenStrategySet entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenStrategySet", id.toString(), this);
    }
  }

  static load(id: string): OneTokenStrategySet | null {
    return changetype<OneTokenStrategySet | null>(
      store.get("OneTokenStrategySet", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value!.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get strategy(): Bytes {
    let value = this.get("strategy");
    return value!.toBytes();
  }

  set strategy(value: Bytes) {
    this.set("strategy", Value.fromBytes(value));
  }

  get allowance(): BigInt {
    let value = this.get("allowance");
    return value!.toBigInt();
  }

  set allowance(value: BigInt) {
    this.set("allowance", Value.fromBigInt(value));
  }
}

export class OneTokenToStrategy extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("strategy", Value.fromBytes(Bytes.empty()));
    this.set("token", Value.fromBytes(Bytes.empty()));
    this.set("amount", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OneTokenToStrategy entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenToStrategy entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenToStrategy", id.toString(), this);
    }
  }

  static load(id: string): OneTokenToStrategy | null {
    return changetype<OneTokenToStrategy | null>(
      store.get("OneTokenToStrategy", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get strategy(): Bytes {
    let value = this.get("strategy");
    return value!.toBytes();
  }

  set strategy(value: Bytes) {
    this.set("strategy", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value!.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class OneTokenTransfer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("from", Value.fromBytes(Bytes.empty()));
    this.set("to", Value.fromBytes(Bytes.empty()));
    this.set("value", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OneTokenTransfer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OneTokenTransfer entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OneTokenTransfer", id.toString(), this);
    }
  }

  static load(id: string): OneTokenTransfer | null {
    return changetype<OneTokenTransfer | null>(
      store.get("OneTokenTransfer", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }
}

export class IchiRariAccrueInterest extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("cashPrior", Value.fromBigInt(BigInt.zero()));
    this.set("interestAccumulated", Value.fromBigInt(BigInt.zero()));
    this.set("borrowIndex", Value.fromBigInt(BigInt.zero()));
    this.set("totalBorrows", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save IchiRariAccrueInterest entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IchiRariAccrueInterest entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IchiRariAccrueInterest", id.toString(), this);
    }
  }

  static load(id: string): IchiRariAccrueInterest | null {
    return changetype<IchiRariAccrueInterest | null>(
      store.get("IchiRariAccrueInterest", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get cashPrior(): BigInt {
    let value = this.get("cashPrior");
    return value!.toBigInt();
  }

  set cashPrior(value: BigInt) {
    this.set("cashPrior", Value.fromBigInt(value));
  }

  get interestAccumulated(): BigInt {
    let value = this.get("interestAccumulated");
    return value!.toBigInt();
  }

  set interestAccumulated(value: BigInt) {
    this.set("interestAccumulated", Value.fromBigInt(value));
  }

  get borrowIndex(): BigInt {
    let value = this.get("borrowIndex");
    return value!.toBigInt();
  }

  set borrowIndex(value: BigInt) {
    this.set("borrowIndex", Value.fromBigInt(value));
  }

  get totalBorrows(): BigInt {
    let value = this.get("totalBorrows");
    return value!.toBigInt();
  }

  set totalBorrows(value: BigInt) {
    this.set("totalBorrows", Value.fromBigInt(value));
  }
}

export class IchiRariApproval extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("owner", Value.fromBytes(Bytes.empty()));
    this.set("spender", Value.fromBytes(Bytes.empty()));
    this.set("amount", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save IchiRariApproval entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IchiRariApproval entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IchiRariApproval", id.toString(), this);
    }
  }

  static load(id: string): IchiRariApproval | null {
    return changetype<IchiRariApproval | null>(
      store.get("IchiRariApproval", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get spender(): Bytes {
    let value = this.get("spender");
    return value!.toBytes();
  }

  set spender(value: Bytes) {
    this.set("spender", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class IchiRariBorrow extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("borrower", Value.fromBytes(Bytes.empty()));
    this.set("borrowAmount", Value.fromBigInt(BigInt.zero()));
    this.set("accountBorrows", Value.fromBigInt(BigInt.zero()));
    this.set("totalBorrows", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save IchiRariBorrow entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IchiRariBorrow entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IchiRariBorrow", id.toString(), this);
    }
  }

  static load(id: string): IchiRariBorrow | null {
    return changetype<IchiRariBorrow | null>(store.get("IchiRariBorrow", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get borrower(): Bytes {
    let value = this.get("borrower");
    return value!.toBytes();
  }

  set borrower(value: Bytes) {
    this.set("borrower", Value.fromBytes(value));
  }

  get borrowAmount(): BigInt {
    let value = this.get("borrowAmount");
    return value!.toBigInt();
  }

  set borrowAmount(value: BigInt) {
    this.set("borrowAmount", Value.fromBigInt(value));
  }

  get accountBorrows(): BigInt {
    let value = this.get("accountBorrows");
    return value!.toBigInt();
  }

  set accountBorrows(value: BigInt) {
    this.set("accountBorrows", Value.fromBigInt(value));
  }

  get totalBorrows(): BigInt {
    let value = this.get("totalBorrows");
    return value!.toBigInt();
  }

  set totalBorrows(value: BigInt) {
    this.set("totalBorrows", Value.fromBigInt(value));
  }
}

export class IchiRariFailure extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("error", Value.fromBigInt(BigInt.zero()));
    this.set("info", Value.fromBigInt(BigInt.zero()));
    this.set("detail", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save IchiRariFailure entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IchiRariFailure entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IchiRariFailure", id.toString(), this);
    }
  }

  static load(id: string): IchiRariFailure | null {
    return changetype<IchiRariFailure | null>(store.get("IchiRariFailure", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get error(): BigInt {
    let value = this.get("error");
    return value!.toBigInt();
  }

  set error(value: BigInt) {
    this.set("error", Value.fromBigInt(value));
  }

  get info(): BigInt {
    let value = this.get("info");
    return value!.toBigInt();
  }

  set info(value: BigInt) {
    this.set("info", Value.fromBigInt(value));
  }

  get detail(): BigInt {
    let value = this.get("detail");
    return value!.toBigInt();
  }

  set detail(value: BigInt) {
    this.set("detail", Value.fromBigInt(value));
  }
}

export class IchiRariLiquidateBorrow extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("liquidator", Value.fromBytes(Bytes.empty()));
    this.set("borrower", Value.fromBytes(Bytes.empty()));
    this.set("repayAmount", Value.fromBigInt(BigInt.zero()));
    this.set("cTokenCollateral", Value.fromBytes(Bytes.empty()));
    this.set("seizeTokens", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save IchiRariLiquidateBorrow entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IchiRariLiquidateBorrow entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IchiRariLiquidateBorrow", id.toString(), this);
    }
  }

  static load(id: string): IchiRariLiquidateBorrow | null {
    return changetype<IchiRariLiquidateBorrow | null>(
      store.get("IchiRariLiquidateBorrow", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get liquidator(): Bytes {
    let value = this.get("liquidator");
    return value!.toBytes();
  }

  set liquidator(value: Bytes) {
    this.set("liquidator", Value.fromBytes(value));
  }

  get borrower(): Bytes {
    let value = this.get("borrower");
    return value!.toBytes();
  }

  set borrower(value: Bytes) {
    this.set("borrower", Value.fromBytes(value));
  }

  get repayAmount(): BigInt {
    let value = this.get("repayAmount");
    return value!.toBigInt();
  }

  set repayAmount(value: BigInt) {
    this.set("repayAmount", Value.fromBigInt(value));
  }

  get cTokenCollateral(): Bytes {
    let value = this.get("cTokenCollateral");
    return value!.toBytes();
  }

  set cTokenCollateral(value: Bytes) {
    this.set("cTokenCollateral", Value.fromBytes(value));
  }

  get seizeTokens(): BigInt {
    let value = this.get("seizeTokens");
    return value!.toBigInt();
  }

  set seizeTokens(value: BigInt) {
    this.set("seizeTokens", Value.fromBigInt(value));
  }
}

export class IchiRariMint extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("minter", Value.fromBytes(Bytes.empty()));
    this.set("mintAmount", Value.fromBigInt(BigInt.zero()));
    this.set("mintTokens", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save IchiRariMint entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IchiRariMint entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IchiRariMint", id.toString(), this);
    }
  }

  static load(id: string): IchiRariMint | null {
    return changetype<IchiRariMint | null>(store.get("IchiRariMint", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get minter(): Bytes {
    let value = this.get("minter");
    return value!.toBytes();
  }

  set minter(value: Bytes) {
    this.set("minter", Value.fromBytes(value));
  }

  get mintAmount(): BigInt {
    let value = this.get("mintAmount");
    return value!.toBigInt();
  }

  set mintAmount(value: BigInt) {
    this.set("mintAmount", Value.fromBigInt(value));
  }

  get mintTokens(): BigInt {
    let value = this.get("mintTokens");
    return value!.toBigInt();
  }

  set mintTokens(value: BigInt) {
    this.set("mintTokens", Value.fromBigInt(value));
  }
}

export class IchiRariNewAdminFee extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("oldAdminFeeMantissa", Value.fromBigInt(BigInt.zero()));
    this.set("newAdminFeeMantissa", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save IchiRariNewAdminFee entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IchiRariNewAdminFee entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IchiRariNewAdminFee", id.toString(), this);
    }
  }

  static load(id: string): IchiRariNewAdminFee | null {
    return changetype<IchiRariNewAdminFee | null>(
      store.get("IchiRariNewAdminFee", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get oldAdminFeeMantissa(): BigInt {
    let value = this.get("oldAdminFeeMantissa");
    return value!.toBigInt();
  }

  set oldAdminFeeMantissa(value: BigInt) {
    this.set("oldAdminFeeMantissa", Value.fromBigInt(value));
  }

  get newAdminFeeMantissa(): BigInt {
    let value = this.get("newAdminFeeMantissa");
    return value!.toBigInt();
  }

  set newAdminFeeMantissa(value: BigInt) {
    this.set("newAdminFeeMantissa", Value.fromBigInt(value));
  }
}

export class IchiRariNewComptroller extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("oldComptroller", Value.fromBytes(Bytes.empty()));
    this.set("newComptroller", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save IchiRariNewComptroller entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IchiRariNewComptroller entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IchiRariNewComptroller", id.toString(), this);
    }
  }

  static load(id: string): IchiRariNewComptroller | null {
    return changetype<IchiRariNewComptroller | null>(
      store.get("IchiRariNewComptroller", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get oldComptroller(): Bytes {
    let value = this.get("oldComptroller");
    return value!.toBytes();
  }

  set oldComptroller(value: Bytes) {
    this.set("oldComptroller", Value.fromBytes(value));
  }

  get newComptroller(): Bytes {
    let value = this.get("newComptroller");
    return value!.toBytes();
  }

  set newComptroller(value: Bytes) {
    this.set("newComptroller", Value.fromBytes(value));
  }
}

export class IchiRariNewFuseFee extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("oldFuseFeeMantissa", Value.fromBigInt(BigInt.zero()));
    this.set("newFuseFeeMantissa", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save IchiRariNewFuseFee entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IchiRariNewFuseFee entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IchiRariNewFuseFee", id.toString(), this);
    }
  }

  static load(id: string): IchiRariNewFuseFee | null {
    return changetype<IchiRariNewFuseFee | null>(
      store.get("IchiRariNewFuseFee", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get oldFuseFeeMantissa(): BigInt {
    let value = this.get("oldFuseFeeMantissa");
    return value!.toBigInt();
  }

  set oldFuseFeeMantissa(value: BigInt) {
    this.set("oldFuseFeeMantissa", Value.fromBigInt(value));
  }

  get newFuseFeeMantissa(): BigInt {
    let value = this.get("newFuseFeeMantissa");
    return value!.toBigInt();
  }

  set newFuseFeeMantissa(value: BigInt) {
    this.set("newFuseFeeMantissa", Value.fromBigInt(value));
  }
}

export class IchiRariNewImplementation extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("oldImplementation", Value.fromBytes(Bytes.empty()));
    this.set("newImplementation", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save IchiRariNewImplementation entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IchiRariNewImplementation entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IchiRariNewImplementation", id.toString(), this);
    }
  }

  static load(id: string): IchiRariNewImplementation | null {
    return changetype<IchiRariNewImplementation | null>(
      store.get("IchiRariNewImplementation", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get oldImplementation(): Bytes {
    let value = this.get("oldImplementation");
    return value!.toBytes();
  }

  set oldImplementation(value: Bytes) {
    this.set("oldImplementation", Value.fromBytes(value));
  }

  get newImplementation(): Bytes {
    let value = this.get("newImplementation");
    return value!.toBytes();
  }

  set newImplementation(value: Bytes) {
    this.set("newImplementation", Value.fromBytes(value));
  }
}

export class IchiRariNewMarketInterestRateModel extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("oldInterestRateModel", Value.fromBytes(Bytes.empty()));
    this.set("newInterestRateModel", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save IchiRariNewMarketInterestRateModel entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IchiRariNewMarketInterestRateModel entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IchiRariNewMarketInterestRateModel", id.toString(), this);
    }
  }

  static load(id: string): IchiRariNewMarketInterestRateModel | null {
    return changetype<IchiRariNewMarketInterestRateModel | null>(
      store.get("IchiRariNewMarketInterestRateModel", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get oldInterestRateModel(): Bytes {
    let value = this.get("oldInterestRateModel");
    return value!.toBytes();
  }

  set oldInterestRateModel(value: Bytes) {
    this.set("oldInterestRateModel", Value.fromBytes(value));
  }

  get newInterestRateModel(): Bytes {
    let value = this.get("newInterestRateModel");
    return value!.toBytes();
  }

  set newInterestRateModel(value: Bytes) {
    this.set("newInterestRateModel", Value.fromBytes(value));
  }
}

export class IchiRariNewReserveFactor extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("oldReserveFactorMantissa", Value.fromBigInt(BigInt.zero()));
    this.set("newReserveFactorMantissa", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save IchiRariNewReserveFactor entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IchiRariNewReserveFactor entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IchiRariNewReserveFactor", id.toString(), this);
    }
  }

  static load(id: string): IchiRariNewReserveFactor | null {
    return changetype<IchiRariNewReserveFactor | null>(
      store.get("IchiRariNewReserveFactor", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get oldReserveFactorMantissa(): BigInt {
    let value = this.get("oldReserveFactorMantissa");
    return value!.toBigInt();
  }

  set oldReserveFactorMantissa(value: BigInt) {
    this.set("oldReserveFactorMantissa", Value.fromBigInt(value));
  }

  get newReserveFactorMantissa(): BigInt {
    let value = this.get("newReserveFactorMantissa");
    return value!.toBigInt();
  }

  set newReserveFactorMantissa(value: BigInt) {
    this.set("newReserveFactorMantissa", Value.fromBigInt(value));
  }
}

export class IchiRariRedeem extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("redeemer", Value.fromBytes(Bytes.empty()));
    this.set("redeemAmount", Value.fromBigInt(BigInt.zero()));
    this.set("redeemTokens", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save IchiRariRedeem entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IchiRariRedeem entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IchiRariRedeem", id.toString(), this);
    }
  }

  static load(id: string): IchiRariRedeem | null {
    return changetype<IchiRariRedeem | null>(store.get("IchiRariRedeem", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get redeemer(): Bytes {
    let value = this.get("redeemer");
    return value!.toBytes();
  }

  set redeemer(value: Bytes) {
    this.set("redeemer", Value.fromBytes(value));
  }

  get redeemAmount(): BigInt {
    let value = this.get("redeemAmount");
    return value!.toBigInt();
  }

  set redeemAmount(value: BigInt) {
    this.set("redeemAmount", Value.fromBigInt(value));
  }

  get redeemTokens(): BigInt {
    let value = this.get("redeemTokens");
    return value!.toBigInt();
  }

  set redeemTokens(value: BigInt) {
    this.set("redeemTokens", Value.fromBigInt(value));
  }
}

export class IchiRariRepayBorrow extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("payer", Value.fromBytes(Bytes.empty()));
    this.set("borrower", Value.fromBytes(Bytes.empty()));
    this.set("repayAmount", Value.fromBigInt(BigInt.zero()));
    this.set("accountBorrows", Value.fromBigInt(BigInt.zero()));
    this.set("totalBorrows", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save IchiRariRepayBorrow entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IchiRariRepayBorrow entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IchiRariRepayBorrow", id.toString(), this);
    }
  }

  static load(id: string): IchiRariRepayBorrow | null {
    return changetype<IchiRariRepayBorrow | null>(
      store.get("IchiRariRepayBorrow", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get payer(): Bytes {
    let value = this.get("payer");
    return value!.toBytes();
  }

  set payer(value: Bytes) {
    this.set("payer", Value.fromBytes(value));
  }

  get borrower(): Bytes {
    let value = this.get("borrower");
    return value!.toBytes();
  }

  set borrower(value: Bytes) {
    this.set("borrower", Value.fromBytes(value));
  }

  get repayAmount(): BigInt {
    let value = this.get("repayAmount");
    return value!.toBigInt();
  }

  set repayAmount(value: BigInt) {
    this.set("repayAmount", Value.fromBigInt(value));
  }

  get accountBorrows(): BigInt {
    let value = this.get("accountBorrows");
    return value!.toBigInt();
  }

  set accountBorrows(value: BigInt) {
    this.set("accountBorrows", Value.fromBigInt(value));
  }

  get totalBorrows(): BigInt {
    let value = this.get("totalBorrows");
    return value!.toBigInt();
  }

  set totalBorrows(value: BigInt) {
    this.set("totalBorrows", Value.fromBigInt(value));
  }
}

export class IchiRariReservesAdded extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("benefactor", Value.fromBytes(Bytes.empty()));
    this.set("addAmount", Value.fromBigInt(BigInt.zero()));
    this.set("newTotalReserves", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save IchiRariReservesAdded entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IchiRariReservesAdded entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IchiRariReservesAdded", id.toString(), this);
    }
  }

  static load(id: string): IchiRariReservesAdded | null {
    return changetype<IchiRariReservesAdded | null>(
      store.get("IchiRariReservesAdded", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get benefactor(): Bytes {
    let value = this.get("benefactor");
    return value!.toBytes();
  }

  set benefactor(value: Bytes) {
    this.set("benefactor", Value.fromBytes(value));
  }

  get addAmount(): BigInt {
    let value = this.get("addAmount");
    return value!.toBigInt();
  }

  set addAmount(value: BigInt) {
    this.set("addAmount", Value.fromBigInt(value));
  }

  get newTotalReserves(): BigInt {
    let value = this.get("newTotalReserves");
    return value!.toBigInt();
  }

  set newTotalReserves(value: BigInt) {
    this.set("newTotalReserves", Value.fromBigInt(value));
  }
}

export class IchiRariReservesReduced extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("admin", Value.fromBytes(Bytes.empty()));
    this.set("reduceAmount", Value.fromBigInt(BigInt.zero()));
    this.set("newTotalReserves", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save IchiRariReservesReduced entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IchiRariReservesReduced entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IchiRariReservesReduced", id.toString(), this);
    }
  }

  static load(id: string): IchiRariReservesReduced | null {
    return changetype<IchiRariReservesReduced | null>(
      store.get("IchiRariReservesReduced", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get admin(): Bytes {
    let value = this.get("admin");
    return value!.toBytes();
  }

  set admin(value: Bytes) {
    this.set("admin", Value.fromBytes(value));
  }

  get reduceAmount(): BigInt {
    let value = this.get("reduceAmount");
    return value!.toBigInt();
  }

  set reduceAmount(value: BigInt) {
    this.set("reduceAmount", Value.fromBigInt(value));
  }

  get newTotalReserves(): BigInt {
    let value = this.get("newTotalReserves");
    return value!.toBigInt();
  }

  set newTotalReserves(value: BigInt) {
    this.set("newTotalReserves", Value.fromBigInt(value));
  }
}

export class IchiRariTransfer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("from", Value.fromBytes(Bytes.empty()));
    this.set("to", Value.fromBytes(Bytes.empty()));
    this.set("amount", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save IchiRariTransfer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IchiRariTransfer entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IchiRariTransfer", id.toString(), this);
    }
  }

  static load(id: string): IchiRariTransfer | null {
    return changetype<IchiRariTransfer | null>(
      store.get("IchiRariTransfer", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class IchiRariSupplyThresholdReached extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("currentRatio", Value.fromString(""));
    this.set("supplyIchi", Value.fromString(""));
    this.set("supplyCap", Value.fromString(""));
    this.set("timeStamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save IchiRariSupplyThresholdReached entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IchiRariSupplyThresholdReached entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IchiRariSupplyThresholdReached", id.toString(), this);
    }
  }

  static load(id: string): IchiRariSupplyThresholdReached | null {
    return changetype<IchiRariSupplyThresholdReached | null>(
      store.get("IchiRariSupplyThresholdReached", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get currentRatio(): string {
    let value = this.get("currentRatio");
    return value!.toString();
  }

  set currentRatio(value: string) {
    this.set("currentRatio", Value.fromString(value));
  }

  get supplyIchi(): string {
    let value = this.get("supplyIchi");
    return value!.toString();
  }

  set supplyIchi(value: string) {
    this.set("supplyIchi", Value.fromString(value));
  }

  get supplyCap(): string {
    let value = this.get("supplyCap");
    return value!.toString();
  }

  set supplyCap(value: string) {
    this.set("supplyCap", Value.fromString(value));
  }

  get timeStamp(): BigInt {
    let value = this.get("timeStamp");
    return value!.toBigInt();
  }

  set timeStamp(value: BigInt) {
    this.set("timeStamp", Value.fromBigInt(value));
  }
}

export class xICHIApproval extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("owner", Value.fromBytes(Bytes.empty()));
    this.set("spender", Value.fromBytes(Bytes.empty()));
    this.set("value", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save xICHIApproval entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save xICHIApproval entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("xICHIApproval", id.toString(), this);
    }
  }

  static load(id: string): xICHIApproval | null {
    return changetype<xICHIApproval | null>(store.get("xICHIApproval", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get spender(): Bytes {
    let value = this.get("spender");
    return value!.toBytes();
  }

  set spender(value: Bytes) {
    this.set("spender", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }
}

export class xICHITransfer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("from", Value.fromBytes(Bytes.empty()));
    this.set("to", Value.fromBytes(Bytes.empty()));
    this.set("value", Value.fromBigInt(BigInt.zero()));
    this.set("ichiAmount", Value.fromBigInt(BigInt.zero()));
    this.set("xICHIAmount", Value.fromBigInt(BigInt.zero()));
    this.set("delta", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("timeStamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save xICHITransfer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save xICHITransfer entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("xICHITransfer", id.toString(), this);
    }
  }

  static load(id: string): xICHITransfer | null {
    return changetype<xICHITransfer | null>(store.get("xICHITransfer", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }

  get ichiAmount(): BigInt {
    let value = this.get("ichiAmount");
    return value!.toBigInt();
  }

  set ichiAmount(value: BigInt) {
    this.set("ichiAmount", Value.fromBigInt(value));
  }

  get xICHIAmount(): BigInt {
    let value = this.get("xICHIAmount");
    return value!.toBigInt();
  }

  set xICHIAmount(value: BigInt) {
    this.set("xICHIAmount", Value.fromBigInt(value));
  }

  get delta(): BigDecimal {
    let value = this.get("delta");
    return value!.toBigDecimal();
  }

  set delta(value: BigDecimal) {
    this.set("delta", Value.fromBigDecimal(value));
  }

  get timeStamp(): BigInt {
    let value = this.get("timeStamp");
    return value!.toBigInt();
  }

  set timeStamp(value: BigInt) {
    this.set("timeStamp", Value.fromBigInt(value));
  }
}
